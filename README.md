* [编译器的实现](#title)
    * [词法分析器](#lex)
    * [词法分析器的工作](#lex-do-what)

<a href="title" ></a>
# 编译器的实现

<a href="lex" ></a>
## 词法分析器

<a href="lex-do-what" ></a>
### 词法分析器的工作

编译器实现的第一步，是将字符流转换成标记流（Token流）。

什么意思呢？我们人类用高级语言编写的程序代码本质上是个文本文件吧，文本文件里面的东西其实就是一坨字符串（String）吧。其实这个字符串，也就是一个一个字符连在一起吧（char[]）。

至于Token是个啥呢？字符串本身没有任何意义，就算用空格将它们分割成一个个小单元，也还是一坨字符串。

比如下面的代码小片段：

```java
public static void main(String[] args) {
    int a = 1234;
    if (a > 0) {
        System.out.println("nice number");
    }
}
``` 
我们人类理解它的时候，是将它看成关键字`public`，关键字`static`，关键字`void`，方法名`main`，左括号`(`，右括号`)`等等。

编译器理解程序也需要注意做，它需要将字符流转换成有意义的标记，将无意义的空白字符都省略掉，（当然对于Python来说，可能……）。有了这样一堆标记，才能在这基础上做下一步的事情。下一步的事情我们先不讲，现在只考虑词法分析器要做的事情。

### 如何描述我们需要的Token

回忆学习第一门新语言的时候，书或老师会告诉我们：
* 一门语言有关键字（保留字）
```
if else public function class 等等
```
* 有标示符，变量名，方法名的规则
```
$abc // php
isGoodBoy
a_1234
都是大多数语言合法的命名方式
```
* 有一些特殊符号
```
() {} [] <>= & | 等等
```
* 以及如何描述字面量
```
123456 // 这是数字
0x123456 // 这也是数字
123456f // 这是浮点数
等等
```
等等其他语言的基本规范，这里就不一一列举了。可以看出来，语言的这些符号，有一些是定死的，有一些则是符合一定规则后就可以随便写的。

比如关键字特殊符号之类的，就是定死的，只能这样写。

而变量名，方法名，数字，只要符合一定规则，就可以随便写出一个合法的变量名，方法名。

现在，我们简化一下问题：**给我们一个字符数组，识别它是个关键字，还是个变量名，还是个数字**。

### 自动机：NFA，DFA

对于问题：**给我们一个字符数组，识别它是个关键字，还是个变量名，还是个数字**

有经验的工程师一定能脑补出来：*啊，如果是一个关键字还好，它是写死的，只需要挨个挨个判断就行了，但是对于变量名和数字就麻烦了，如果要写if-else，感觉会有一个无穷无尽的循环在那里等着我。*

```
char c;
while (c = nextChar()) {
    if (c == 'e') {
        c = nextChar();
        if (c == 'l') {
            c = nextChar();
            if (c == 's') {
                c = nextChar();
                if (c == 'e') {
                    c = nextChar();
                    if (c == ' ') {
                        // 太棒了，我终于识别到一个else了！
                    }
                }
            }
        }
    }
}
```

显然，如果靠手工编码来写识别token的逻辑几乎是不可能完成的任务，这个时候我们就需要一些理论上的指导了。

// todo

1. 将正则表达式转换为语法树的节点

使用栈来解决这个问题

2. 将正则表达式（语法树表示）转换成NFA

有了语法树结构的正则表达式，转移成NFA就成了一件非常容易轻松的事情了。我们只需要对每种节点单独处理就好了，如果这个节点，复合了其他类型的节点，那就交给它自己的方法去实现，充分的发挥了面向对象语言继承的威力。

在这个过程中，我遇到了三个问题：
   * 怎么标记接收（accept）状态？
   * 怎么去除空边？
   * 生成的NFA对象如何进行测试？
   
#### 问题1：怎么标记接收（accept）状态？
3. 将NFA转换为DFA
4. 最小化DFA